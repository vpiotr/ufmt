/**
 * @mainpage ufmt - Micro String Formatting Library
 * 
 * @section intro_sec Introduction
 * 
 * **ufmt** is a lightweight, header-only C++11 micro-library for string template formatting with support for custom formatters, named variables, and both local and shared contexts.
 * 
 * @section features_sec Key Features
 * 
 * - **Simple API**: Minimal, intuitive interface for string formatting
 * - **Positional & Named Placeholders**: Support for `{0}`, `{1}` and `{variable_name}` syntax
 * - **Printf-style Formatting**: Advanced format specifications like `{0:.2f}`, `{1:08x}`
 * - **Custom Formatters**: Easy integration of user-defined type formatters
 * - **Context Management**: Local (RAII), shared (thread-safe), and internal contexts
 * - **Thread Safety**: Safe concurrent access to shared contexts
 * - **C++11 Compatible**: No external dependencies, works with older compilers
 * - **Header-Only**: Just include `ufmt.h` - no linking required
 * - **Optional ustr.h Integration**: Universal type conversion support
 * 
 * @section quick_start_sec Quick Start
 * 
 * @subsection basic_usage Basic Usage
 * 
 * @code{.cpp}
 * #include "ufmt/ufmt.h"
 * 
 * // Simple positional formatting
 * std::string msg = ufmt::format("User {0} has {1} messages", "Alice", 5);
 * // Result: "User Alice has 5 messages"
 * 
 * // Format specifications
 * std::string precise = ufmt::format("Pi = {0:.3f}", 3.14159);
 * // Result: "Pi = 3.142"
 * 
 * // Multiple types
 * std::string mixed = ufmt::format("Score: {0}, Active: {1}", 87.5, true);
 * // Result: "Score: 87.500000, Active: true"
 * @endcode
 * 
 * @subsection local_context Local Context (RAII)
 * 
 * @code{.cpp}
 * // Create local context with custom formatter
 * auto ctx = ufmt::create_local_context();
 * ctx->set_formatter<bool>([](bool b) { return b ? "YES" : "NO"; });
 * 
 * std::string result = ctx->format("Rendering: {0}", true);
 * // Result: "Rendering: YES"
 * 
 * // Named variables
 * ctx->set_var("user", "Bob");
 * ctx->set_var("level", 12);
 * std::string status = ctx->format("Player {user} reached level {level}");
 * // Result: "Player Bob reached level 12"
 * @endcode
 * 
 * @subsection shared_context Shared Context (Thread-Safe)
 * 
 * @code{.cpp}
 * // Named shared context - thread-safe
 * auto api_ctx = ufmt::get_shared_context("api");
 * api_ctx->set_var("endpoint", "/users");
 * api_ctx->set_var("method", "POST");
 * 
 * // Can be used from multiple threads
 * std::string log_msg = api_ctx->format("Request {method} {endpoint} completed");
 * // Result: "Request POST /users completed"
 * @endcode
 * 
 * @section contexts_sec Context Types
 * 
 * ufmt provides three types of formatting contexts:
 * 
 * @subsection internal_context 1. Internal Context (Implicit)
 * - Used automatically by ufmt::format() function
 * - No variable storage or custom formatters
 * - Maximum performance for simple formatting
 * - Thread-safe (stateless)
 * 
 * @subsection local_context_detailed 2. Local Context (Single-thread)
 * - Fast, RAII-based context for single-thread use
 * - Supports variables and custom formatters
 * - Not thread-safe (by design)
 * - Available as value type or smart pointer
 * 
 * @subsection shared_context_detailed 3. Shared Context (Thread-safe)
 * - Thread-safe context with mutex protection
 * - Supports variables and custom formatters
 * - Can be named and shared between threads
 * - Transparent variable management (main thread vs worker threads)
 * 
 * @section format_specs_sec Format Specifications
 * 
 * ufmt supports printf-style format specifications:
 * 
 * @subsection float_format Floating Point
 * - `{0:.2f}` - 2 decimal places: `3.14`
 * - `{0:.3e}` - Scientific notation: `3.142e+00`
 * - `{0:8.2f}` - Width 8, 2 decimals: `    3.14`
 * 
 * @subsection int_format Integers
 * - `{0:d}` - Decimal: `255`
 * - `{0:x}` - Hexadecimal: `ff`
 * - `{0:X}` - Uppercase hex: `FF`
 * - `{0:o}` - Octal: `377`
 * - `{0:b}` - Binary: `0b11111111`
 * - `{0:08d}` - Zero-padded: `00000255`
 * - `{0:016b}` - Zero-padded binary: `0b0000000011111111`
 * 
 * @subsection string_format Strings
 * - `{0:10}` - Right-aligned, width 10: `     hello`
 * - `{0:-10}` - Left-aligned, width 10: `hello     `
 * 
 * @section custom_types_sec Custom Types
 * 
 * @code{.cpp}
 * struct Point {
 *     int x, y;
 *     Point(int x, int y) : x(x), y(y) {}
 * };
 * 
 * // Extend ufmt::to_string for your type
 * namespace ufmt {
 *     template<>
 *     std::string to_string<Point>(const Point& p) {
 *         return "(" + std::to_string(p.x) + ", " + std::to_string(p.y) + ")";
 *     }
 * }
 * 
 * // Usage
 * Point p(10, 20);
 * std::string msg = ufmt::format("Position: {0}", p);
 * // Result: "Position: (10, 20)"
 * @endcode
 * 
 * @section ustr_integration_sec Optional ustr.h Integration
 * 
 * ufmt can optionally integrate with ustr.h for universal type conversion:
 * 
 * @code{.cpp}
 * #include "ustr.h"           // Include ustr.h first
 * #define UFMT_USE_USTR       // Enable ustr integration
 * #include "ufmt.h"           // ufmt will now use ustr::to_string()
 * 
 * // Now ufmt will use ustr::to_string() for all type conversions
 * struct CustomType { int value; };
 * CustomType obj{42};
 * std::string result = ufmt::format("Object: {0}", obj); // Uses ustr::to_string(obj)
 * @endcode
 * 
 * @section thread_safety_sec Thread Safety
 * 
 * - **Global format() function**: Thread-safe
 * - **Local contexts**: NOT thread-safe (single-thread use only)
 * - **Shared contexts**: Fully thread-safe with internal synchronization
 * - **Context manager**: Thread-safe context creation and retrieval
 * 
 * @section performance_sec Performance
 * 
 * ufmt is designed for efficiency:
 * 
 * - **Zero Allocation**: for simple cases without format specifications
 * - **Minimal Overhead**: direct string manipulation without parsing trees
 * - **Template Optimization**: compile-time type handling
 * - **Lock-Free Reading**: local contexts are very fast
 * - **Fine-Grained Locking**: shared contexts use mutex only when needed
 * 
 * @section error_handling_sec Error Handling
 * 
 * @code{.cpp}
 * try {
 *     auto result = ufmt::format("Invalid {0:.invalid}", 3.14);
 * } catch (const ufmt::format_error& e) {
 *     // Handle formatting errors
 * } catch (const ufmt::parse_error& e) {
 *     // Handle template parsing errors  
 * } catch (const ufmt::argument_error& e) {
 *     // Handle argument-related errors
 * }
 * @endcode
 * 
 * @section examples_sec Examples and Demos
 * 
 * The project includes several comprehensive demos:
 * 
 * - **demo_basic.cpp**: Basic formatting features and API usage
 * - **demo_multithreading.cpp**: Thread-safe context usage examples  
 * - **demo_transparent_api.cpp**: Transparent API demonstrations
 * - **demo_ustr_integration.cpp**: Optional ustr.h integration showcase
 * - **benchmark_basic.cpp**: Performance benchmarking
 * - **benchmark_multithreading.cpp**: Multi-threading performance tests
 * 
 * @section building_sec Building and Testing
 * 
 * @subsection prerequisites Prerequisites
 * - C++11 compatible compiler (GCC 4.8+, Clang 3.3+, MSVC 2015+)
 * - CMake 3.10+
 * 
 * @subsection build_commands Build Commands
 * 
 * ```bash
 * # Complete rebuild
 * ./rebuild.sh
 * 
 * # Run all tests
 * ./run_tests.sh
 * 
 * # Run all demos
 * ./run_demos.sh
 * 
 * # Run benchmarks
 * ./run_benchmarks.sh
 * 
 * # Build documentation
 * ./build_docs.sh
 * ```
 * 
 * @section license_sec License
 * 
 * This project is licensed under the MIT License.
 * 
 * @section author_sec Author
 * 
 * **Piotr Likus** - [GitHub](https://github.com/vpiotr)
 * 
 * @version 1.0
 * @date 2025
 */
